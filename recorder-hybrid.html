<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Run Tracker V15 (Compass+Stealth)</title>
    <style>
        body { margin: 0; background: #000; color: white; font-family: sans-serif; overflow: hidden; height: 100vh; display: flex; flex-direction: column; }
        #video-container { position: relative; flex-grow: 1; background: #111; display: flex; align-items: center; justify-content: center; overflow: hidden; }
        video { width: 100%; height: 100%; object-fit: cover; }
        
        /* DATA OVERLAY */
        #overlay-data { position: absolute; top: 10px; left: 10px; z-index: 10; font-family: monospace; font-size: 14px; text-shadow: 1px 1px 2px black; pointer-events: none; }
        
        /* CONTROLS */
        #controls { height: 120px; background: #111; display: grid; grid-template-columns: 1fr 1fr 1fr 0.5fr; gap: 10px; padding: 10px; border-top: 1px solid #333; z-index: 20; }
        button { border: none; border-radius: 12px; font-weight: bold; font-size: 16px; color: white; cursor: pointer; display: flex; flex-direction: column; align-items: center; justify-content: center; }
        .btn-rec { background: #ff4444; }
        .btn-rec.recording { background: white; color: red; animation: pulse 1s infinite; }
        .btn-photo { background: #444; }
        .btn-finish { background: #00e676; color: #003300; }
        .btn-stealth { background: #222; color: #555; font-size: 20px; }
        
        @keyframes pulse { 0% { opacity: 1; } 50% { opacity: 0.5; } 100% { opacity: 1; } }
        #status-toast { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0,0,0,0.8); padding: 15px 25px; border-radius: 30px; font-size: 18px; pointer-events: none; opacity: 0; transition: opacity 0.3s; z-index: 50; border: 1px solid #555; text-align: center; }

        /* STEALTH CURTAIN */
        #curtain { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: black; z-index: 9999; display: none; }
        #curtain-msg { position: absolute; bottom: 50px; width: 100%; text-align: center; color: #333; font-size: 12px; }
    </style>
</head>
<body>
    <div id="video-container">
        <video id="preview" autoplay playsinline muted></video>
        <div id="overlay-data">
            <div>GPS: <span id="gps-status">Waiting...</span></div>
            <div>Hdg: <span id="heading-display">--</span>¬∞</div>
            <div>Spd: <span id="speed">0.0</span> km/h</div>
            <div>Rec: <span id="rec-timer">00:00</span></div>
            <div>Clips: <span id="clip-count">0</span></div>
        </div>
        <div id="status-toast"></div>
    </div>

    <div id="controls">
        <button class="btn-photo" onclick="takePhoto()">üì∏</button>
        <button class="btn-rec" id="btn-rec" onclick="toggleRecording()">üî¥ REC</button>
        <button class="btn-finish" onclick="finishSession()">üèÅ</button>
        <button class="btn-stealth" onclick="toggleStealth()">üëÅÔ∏è</button>
    </div>

    <div id="curtain" onclick="toggleStealth()">
        <div id="curtain-msg">Recording in background... Tap to wake.</div>
    </div>

    <script>
        const DB_VERSION = 106;
        const DB_NAME = "RunTrackerDB";

        let mediaStream, mediaRecorder;
        let chunks = [];
        let isRecording = false;
        let startTime = 0;
        let recordTimerInt;
        let sessionID = Date.now();
        let sessionDateStr = "";
        let clipIndex = 1;
        
        let trackPoints = [];
        let photos = [];
        let videoMeta = [];
        
        // --- COMPASS VARIABLES ---
        let magneticHeading = 0; // The fallback heading

        async function init() {
            // 1. Session Name
            const now = new Date();
            sessionDateStr = `Run_${now.toISOString().split('T')[0]}_${now.toTimeString().split(' ')[0].replace(/:/g, '-')}`;

            // 2. Continuous Compass Listener
            if (window.DeviceOrientationEvent) {
                window.addEventListener('deviceorientation', (event) => {
                    if (event.webkitCompassHeading) {
                        // iOS
                        magneticHeading = event.webkitCompassHeading;
                    } else if (event.alpha) {
                        // Android (Approximate, alpha is technically z-axis rotation)
                        magneticHeading = 360 - event.alpha;
                    }
                }, true);
            }

            try {
                // 3. Camera
                mediaStream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment" }, audio: true });
                document.getElementById('preview').srcObject = mediaStream;

                // 4. GPS
                navigator.geolocation.watchPosition(
                    pos => {
                        const { latitude, longitude, speed, altitude, heading } = pos.coords;
                        
                        // --- HEADING LOGIC V15 ---
                        // If GPS heading is valid (>0), use it. If not, use Magnetic.
                        let finalHeading = heading;
                        let headingSource = "GPS";

                        if (!heading || isNaN(heading) || (heading === 0 && speed < 1)) {
                            finalHeading = magneticHeading;
                            headingSource = "Mag";
                        }

                        // Update UI
                        document.getElementById('gps-status').innerText = `${latitude.toFixed(5)}, ${longitude.toFixed(5)}`;
                        document.getElementById('speed').innerText = ((speed || 0) * 3.6).toFixed(1);
                        document.getElementById('heading-display').innerText = `${Math.round(finalHeading || 0)}`;

                        const point = {
                            time: (Date.now() - sessionID) / 1000,
                            lat: latitude, lng: longitude,
                            speed: speed, 
                            alt: altitude, 
                            heading: finalHeading, // Store the fused heading
                            headingSrc: headingSource // Store which one we used (for debugging)
                        };
                        trackPoints.push(point);
                    },
                    err => console.error(err),
                    { enableHighAccuracy: true }
                );

            } catch (e) { alert("Error: " + e.message); }
        }
        init();

        // --- STEALTH LOGIC ---
        function toggleStealth() {
            const c = document.getElementById('curtain');
            c.style.display = (c.style.display === 'block') ? 'none' : 'block';
        }

        // --- RECORDING (Standard V14 Logic) ---
        function toggleRecording() {
            if (!isRecording) startRecording();
            else stopRecording();
        }

        function startRecording() {
            chunks = [];
            try { mediaRecorder = new MediaRecorder(mediaStream, { mimeType: 'video/mp4; codecs=avc1' }); } 
            catch (e) { mediaRecorder = new MediaRecorder(mediaStream); }

            mediaRecorder.ondataavailable = e => { if (e.data.size > 0) chunks.push(e.data); };
            mediaRecorder.onstop = async () => {
                const blob = new Blob(chunks, { type: 'video/mp4' });
                const clipName = `${sessionDateStr}_Clip_${String(clipIndex).padStart(2, '0')}.mp4`;
                await saveVideoChunkToDB(blob, clipName);
                videoMeta.push({ filename: clipName, startTime: (startTime - sessionID)/1000, endTime: (Date.now() - sessionID)/1000 });
                showToast(`‚úÖ Saved: Clip ${clipIndex}`);
                document.getElementById('clip-count').innerText = videoMeta.length;
                clipIndex++;
            };
            mediaRecorder.start();
            isRecording = true;
            startTime = Date.now();
            updateUI(true);
        }

        function stopRecording() {
            mediaRecorder.stop();
            isRecording = false;
            updateUI(false);
        }

        function takePhoto() {
            const track = mediaStream.getVideoTracks()[0];
            const imageCapture = new ImageCapture(track);
            imageCapture.takePhoto().then(blob => {
                const reader = new FileReader();
                reader.onloadend = () => {
                    const lastPt = trackPoints[trackPoints.length-1] || {lat:0, lng:0, heading: magneticHeading};
                    photos.push({
                        time: (Date.now() - sessionID) / 1000,
                        lat: lastPt.lat,
                        lng: lastPt.lng,
                        heading: lastPt.heading || magneticHeading, // Photo heading
                        src: reader.result
                    });
                    showToast("üì∏ Photo");
                };
                reader.readAsDataURL(blob);
            });
        }

        function saveVideoChunkToDB(blob, filename) {
            return new Promise((resolve, reject) => {
                const req = indexedDB.open(DB_NAME, DB_VERSION);
                req.onupgradeneeded = e => {
                    const db = e.target.result;
                    if (!db.objectStoreNames.contains("sessions")) db.createObjectStore("sessions", { keyPath: "id" });
                    if (!db.objectStoreNames.contains("videos")) db.createObjectStore("videos", { keyPath: "filename" });
                };
                req.onsuccess = e => {
                    const tx = e.target.result.transaction("videos", "readwrite");
                    tx.objectStore("videos").put({ filename: filename, blob: blob });
                    tx.oncomplete = () => resolve();
                };
            });
        }

        function finishSession() {
            if (isRecording) stopRecording();
            if (!confirm("Finish Run?")) return;
            const finalData = { id: sessionID, date: new Date().toISOString(), duration: (Date.now() - sessionID)/1000, track_points: trackPoints, photos: photos, videoData: videoMeta };
            const req = indexedDB.open(DB_NAME, DB_VERSION);
            req.onsuccess = e => {
                const tx = e.target.result.transaction("sessions", "readwrite");
                tx.objectStore("sessions").put(finalData);
                tx.oncomplete = () => window.location.href = 'session-manager.html';
            };
        }

        function updateUI(recording) {
            const btn = document.getElementById('btn-rec');
            if (recording) {
                btn.classList.add('recording');
                btn.innerText = "‚èπ";
                let s = 0;
                recordTimerInt = setInterval(() => { s++; document.getElementById('rec-timer').innerText = `${Math.floor(s/60).toString().padStart(2,'0')}:${(s%60).toString().padStart(2,'0')}`; }, 1000);
            } else {
                btn.classList.remove('recording');
                btn.innerText = "üî¥ REC";
                clearInterval(recordTimerInt);
            }
        }

        function showToast(msg) {
            const t = document.getElementById('status-toast'); t.innerText = msg; t.style.opacity = 1;
            setTimeout(() => t.style.opacity = 0, 2000);
        }
    </script>
</body>
</html>